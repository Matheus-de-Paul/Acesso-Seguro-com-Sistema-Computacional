import cv2
import pickle
import face_recognition
import time
import paho.mqtt.client as mqtt
import ssl
from datetime import datetime

# ------------------------------------------------
# ConfiguraÃ§Ãµes HiveMQ / MQTT
# ------------------------------------------------
MQTT_HOST = "#colocar o seu#"
MQTT_PORT = #sua porta#
MQTT_USER = "#seu usuÃ¡rio#"
MQTT_PASS = "#sua senha#"
TOPIC_BASE = "#seu tÃ³pico#"
COOLDOWN = 15.0   # segundos entre novas publicaÃ§Ãµes para evitar spam

# ------------------------------------------------
# FunÃ§Ãµes MQTT
# ------------------------------------------------
def on_connect(client, userdata, flags, rc):
    if rc == 0:
        print("âœ… Conectado ao HiveMQ")
    else:
        print("âš ï¸ Erro ao conectar. CÃ³digo:", rc)

def setup_mqtt():
    client = mqtt.Client()
    client.username_pw_set(MQTT_USER, MQTT_PASS)
    client.tls_set(cert_reqs=ssl.CERT_REQUIRED)
    client.on_connect = on_connect
    client.connect(MQTT_HOST, MQTT_PORT)
    client.loop_start()
    return client

def mqtt_publish(client, topic_suffix, message):
    topic = f"{TOPIC_BASE}/{topic_suffix}"
    client.publish(topic, message)
    print(f"ðŸ“¤ Publicado -> {topic}: {message}")

# Inicia cliente MQTT
mqtt_client = setup_mqtt()

# ------------------------------------------------
# ConfiguraÃ§Ãµes de reconhecimento facial
# ------------------------------------------------
ENCODINGS_FILE = "encodings.pkl"
CAMERA_INDEX = 0

# Carrega encodings
with open(ENCODINGS_FILE, "rb") as f:
    data = pickle.load(f)
known_encodings = data["encodings"]
known_names = data["names"]

# Abre cÃ¢mera
cap = cv2.VideoCapture(CAMERA_INDEX)
if not cap.isOpened():
    raise SystemExit("NÃ£o foi possÃ­vel abrir a cÃ¢mera")

print("Pressione 'q' para sair.")

# ------------------------------------------------
# Controle de entradas e saÃ­das
# ------------------------------------------------
estado_pessoas = {}   # ex: {"JoÃ£o": {"status": "dentro", "entrada": "10:22:00"}}
ultimo_envio = time.time()

# ------------------------------------------------
# Loop principal
# ------------------------------------------------
while True:
    ret, frame = cap.read()
    if not ret:
        break

    rgb_frame = cv2.cvtColor(frame, cv2.COLOR_BGR2RGB)

    face_locations = face_recognition.face_locations(rgb_frame)
    face_encodings = face_recognition.face_encodings(rgb_frame, face_locations)

    for (top, right, bottom, left), face_encoding in zip(face_locations, face_encodings):
        matches = face_recognition.compare_faces(known_encodings, face_encoding)
        name = "Desconhecido"

        if True in matches:
            first_match_index = matches.index(True)
            name = known_names[first_match_index]

        # Desenha retÃ¢ngulo e nome
        color = (0, 255, 0) if name != "Desconhecido" else (0, 0, 255)
        cv2.rectangle(frame, (left, top), (right, bottom), color, 2)
        cv2.putText(frame, name, (left, top - 10),
                    cv2.FONT_HERSHEY_SIMPLEX, 0.8, color, 2)

        # ------------------------------------------------------------------
        #  LÃ³gica NOVA: registrar entrada e saÃ­da
        # ------------------------------------------------------------------
        agora = datetime.now().strftime("%H:%M:%S")

        if name != "Desconhecido" and (time.time() - ultimo_envio > COOLDOWN):

            if name not in estado_pessoas:
                # âž¤ PRIMEIRA DETECÃ‡ÃƒO â†’ ENTRADA
                estado_pessoas[name] = {"status": "dentro", "entrada": agora}
                mqtt_publish(mqtt_client, "entrada",
                             f"{name} entrou Ã s {agora}")
                print(f"ðŸ“Œ {name} ENTRADA registrada Ã s {agora}")

            else:
                if estado_pessoas[name]["status"] == "dentro":
                    # âž¤ SEGUNDA DETECÃ‡ÃƒO â†’ SAÃDA
                    estado_pessoas[name]["status"] = "fora"
                    estado_pessoas[name]["saida"] = agora
                    mqtt_publish(mqtt_client, "saida",
                                 f"{name} saiu Ã s {agora}")
                    print(f"ðŸ“Œ {name} SAÃDA registrada Ã s {agora}")

                else:
                    # âž¤ Depois da saÃ­da â†’ nova ENTRADA
                    estado_pessoas[name] = {"status": "dentro", "entrada": agora}
                    mqtt_publish(mqtt_client, "entrada",
                                 f"{name} entrou novamente Ã s {agora}")
                    print(f"ðŸ“Œ {name} NOVA ENTRADA Ã s {agora}")

            ultimo_envio = time.time()

        elif name == "Desconhecido" and (time.time() - ultimo_envio > COOLDOWN):
            mqtt_publish(mqtt_client, "negado",
                         f"Acesso negado Ã s {agora}")
            ultimo_envio = time.time()

    cv2.imshow("Reconhecimento Facial", frame)

    if cv2.waitKey(1) & 0xFF == ord("q"):
        break

cap.release()
cv2.destroyAllWindows()
